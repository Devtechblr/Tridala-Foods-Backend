import mongoose from 'mongoose';
import Category from '../models/Category.js';
import Product from '../models/Product.js';

/**
 * ============================================
 * ADMIN CATEGORY CONTROLLER
 * ============================================
 * Handles all admin category management operations
 * Implements complete CRUD functionality for category administration
 */

/**
 * Create a new category
 * Validates required fields and checks for duplicate names
 * Automatically generates slug from category name
 *
 * @route   POST /api/admin/categories
 * @access  Admin only
 *
 * @param {string} name - Category name (required)
 * @param {string} description - Category description (optional)
 */
export const createCategory = async (req, res, next) => {
  try {
    const { name, description } = req.body;

    // Validate required fields
    if (!name || name.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'Category name is required',
      });
    }

    // Check if category with this name already exists (case-insensitive)
    const existingCategory = await Category.findOne({
      name: { $regex: `^${name.trim()}$`, $options: 'i' },
    });

    if (existingCategory) {
      return res.status(400).json({
        success: false,
        message: 'A category with this name already exists',
      });
    }

    // Create category object
    const categoryData = {
      name: name.trim(),
      description: description ? description.trim() : undefined,
    };

    // Remove undefined fields
    Object.keys(categoryData).forEach((key) => categoryData[key] === undefined && delete categoryData[key]);

    // Create and save category (slug auto-generated by pre-save hook)
    const category = new Category(categoryData);
    await category.save();

    res.status(201).json({
      success: true,
      message: 'Category created successfully',
      data: category,
    });
  } catch (error) {
    // Handle Mongoose validation errors
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors)
        .map((err) => err.message)
        .join(', ');
      return res.status(400).json({
        success: false,
        message: messages,
      });
    }

    // Handle duplicate slug error
    if (error.code === 11000 && error.keyPattern?.slug) {
      return res.status(400).json({
        success: false,
        message: 'A category with this name already exists',
      });
    }

    next(error);
  }
};

/**
 * Get all categories (admin view)
 * Returns all categories sorted by creation date in descending order
 * Includes product count for each category
 *
 * @route   GET /api/admin/categories
 * @access  Admin only
 *
 * @query {number} page - Page number for pagination (default: 1)
 * @query {number} limit - Items per page (default: 20)
 * @query {string} search - Search by category name
 * @query {string} sort - Sort field (default: -createdAt)
 */
export const getAllAdminCategories = async (req, res, next) => {
  try {
    const { page = 1, limit = 20, search, sort = '-createdAt' } = req.query;

    // Parse pagination parameters
    const pageNum = Math.max(1, parseInt(page));
    const limitNum = Math.max(1, Math.min(100, parseInt(limit))); // Cap at 100
    const skip = (pageNum - 1) * limitNum;

    // Build filter object
    const filter = {};

    // Search filter - case-insensitive name search
    if (search) {
      filter.name = { $regex: search, $options: 'i' };
    }

    // Execute query with filters, pagination, and sorting
    const categories = await Category.find(filter)
      .sort(sort)
      .skip(skip)
      .limit(limitNum)
      .lean();

    // Get product count for each category
    const categoriesWithCounts = await Promise.all(
      categories.map(async (category) => {
        const productCount = await Product.countDocuments({ category: category._id });
        return {
          ...category,
          productCount,
        };
      })
    );

    // Get total count for pagination info
    const total = await Category.countDocuments(filter);

    res.status(200).json({
      success: true,
      message: 'Categories retrieved successfully',
      data: categoriesWithCounts,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        pages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get single category by ID (admin view)
 * Returns complete category information with product count
 *
 * @route   GET /api/admin/categories/:id
 * @access  Admin only
 *
 * @param {string} id - Category ID (MongoDB ObjectId)
 */
export const getAdminCategoryById = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Validate ObjectId format
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid category ID format',
      });
    }

    // Fetch category
    const category = await Category.findById(id);

    // Return 404 if category not found
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found',
      });
    }

    // Get product count for this category
    const productCount = await Product.countDocuments({ category: id });

    res.status(200).json({
      success: true,
      message: 'Category retrieved successfully',
      data: {
        ...category.toObject(),
        productCount,
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Update category by ID
 * Allows updating name and description
 * Slug is auto-updated if name changes (via pre-save hook)
 *
 * @route   PUT /api/admin/categories/:id
 * @access  Admin only
 *
 * @param {string} id - Category ID (MongoDB ObjectId)
 * @param {object} req.body - Fields to update (all optional)
 */
export const updateCategory = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    // Validate ObjectId format
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid category ID format',
      });
    }

    // Check if category exists
    const category = await Category.findById(id);
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found',
      });
    }

    // If name is being updated, check for duplicates
    if (updateData.name && updateData.name.trim() !== category.name) {
      const existingCategory = await Category.findOne({
        _id: { $ne: id },
        name: { $regex: `^${updateData.name.trim()}$`, $options: 'i' },
      });

      if (existingCategory) {
        return res.status(400).json({
          success: false,
          message: 'A category with this name already exists',
        });
      }

      // Trim the name
      updateData.name = updateData.name.trim();
    }

    // Trim description if being updated
    if (updateData.description) {
      updateData.description = updateData.description.trim();
    }

    // Update category and return new document
    const updatedCategory = await Category.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true,
    });

    res.status(200).json({
      success: true,
      message: 'Category updated successfully',
      data: updatedCategory,
    });
  } catch (error) {
    // Handle Mongoose validation errors
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors)
        .map((err) => err.message)
        .join(', ');
      return res.status(400).json({
        success: false,
        message: messages,
      });
    }

    // Handle duplicate slug error
    if (error.code === 11000 && error.keyPattern?.slug) {
      return res.status(400).json({
        success: false,
        message: 'A category with this name already exists',
      });
    }

    next(error);
  }
};

/**
 * Delete category by ID
 * Checks if category has any products before deletion
 * Prevents deletion if products exist under this category
 * Performs hard delete from the database
 *
 * @route   DELETE /api/admin/categories/:id
 * @access  Admin only
 *
 * @param {string} id - Category ID (MongoDB ObjectId)
 */
export const deleteCategory = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Validate ObjectId format
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid category ID format',
      });
    }

    // Check if category exists
    const category = await Category.findById(id);
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found',
      });
    }

    // Check if category has any products
    const productCount = await Product.countDocuments({ category: id });
    if (productCount > 0) {
      return res.status(400).json({
        success: false,
        message: `Cannot delete a category that still has products. This category contains ${productCount} product(s).`,
      });
    }

    // Delete category from database
    await Category.findByIdAndDelete(id);

    res.status(200).json({
      success: true,
      message: 'Category deleted successfully',
      data: {
        _id: category._id,
        name: category.name,
      },
    });
  } catch (error) {
    next(error);
  }
};
